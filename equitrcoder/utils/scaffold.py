"""Scaffolding helpers for EQUITR Coder extensions."""

from __future__ import annotations

import textwrap
from pathlib import Path
from typing import Dict, Optional

from .paths import get_user_extensions_root


class ScaffoldError(RuntimeError):
    """Raised when scaffolding cannot be completed."""


def resolve_extension_root(root: Optional[str] = None, create: bool = False) -> Path:
    """Resolve the base directory for extensions."""

    if root:
        path = Path(root).expanduser().resolve()
        if create:
            path.mkdir(parents=True, exist_ok=True)
        return path

    return get_user_extensions_root(create=create)


def ensure_extension_structure(root: Optional[str] = None) -> Dict[str, Path]:
    """Ensure the standard extension directory layout exists."""

    base = resolve_extension_root(root, create=True)
    directories = {
        "root": base,
        "tools": base / "tools",
        "profiles": base / "profiles",
        "modes": base / "modes",
        "config": base / "config",
    }

    for key, path in directories.items():
        if key == "root":
            continue
        path.mkdir(parents=True, exist_ok=True)

    for pkg_dir in (directories["tools"], directories["modes"]):
        init_file = pkg_dir / "__init__.py"
        if not init_file.exists():
            init_file.write_text(
                '"""Custom extensions discovered by EQUITR Coder."""\n',
                encoding="utf-8",
            )

    prompts_file = directories["config"] / "system_prompt.yaml"
    if not prompts_file.exists():
        prompts_file.write_text(
            textwrap.dedent(
                """
                # Custom prompts merged after packaged defaults
                custom_prompts: {}
                """
            ).strip()
            + "\n",
            encoding="utf-8",
        )

    return directories


def scaffold_tool(
    name: str,
    *,
    root: Optional[str] = None,
    description: Optional[str] = None,
    force: bool = False,
) -> Path:
    directories = ensure_extension_structure(root)
    snake = _to_snake_case(name)
    class_name = _to_camel_case(name)
    file_path = directories["tools"] / f"{snake}.py"
    if file_path.exists() and not force:
        raise ScaffoldError(f"Tool file already exists: {file_path}")

    template = textwrap.dedent(
        f'''"""Custom tool '{snake}'."""

        from typing import Type

        from pydantic import BaseModel, Field

        from equitrcoder.tools.base import Tool, ToolResult


        class {class_name}Args(BaseModel):
            """Arguments for the {snake} tool."""

            example: str = Field(..., description="Example argument input")


        class {class_name}(Tool):
            """{description or 'Custom tool generated by equitrcoder CLI.'}"""

            def get_name(self) -> str:
                return "{snake}"

            def get_description(self) -> str:
                return "{description or 'Custom extension tool.'}"

            def get_args_schema(self) -> Type[BaseModel]:
                return {class_name}Args

            async def run(self, **kwargs) -> ToolResult:
                args = self.validate_args(kwargs)
                message = f"{snake} executed with example={{args.example}}"
                return ToolResult(success=True, data={"message": message})
'''
    ).strip()

    file_path.write_text(template + "\n", encoding="utf-8")
    return file_path


def scaffold_profile(
    name: str,
    *,
    root: Optional[str] = None,
    description: Optional[str] = None,
    force: bool = False,
) -> Path:
    directories = ensure_extension_structure(root)
    slug = _to_kebab_case(name)
    file_path = directories["profiles"] / f"{slug}.yaml"
    if file_path.exists() and not force:
        raise ScaffoldError(f"Profile file already exists: {file_path}")

    display_name = description or f"Custom profile {slug}"
    template = textwrap.dedent(
        f"""
        name: "{_to_title_case(slug)}"
        description: "{display_name}"
        system_prompt: |
          You are {display_name}. Combine reasoning with the provided custom tools.

        allowed_tools:
          - read_file
          - edit_file
          - run_command
          - { _to_snake_case(name) }
        """
    ).strip()

    file_path.write_text(template + "\n", encoding="utf-8")
    return file_path


def scaffold_mode(
    name: str,
    *,
    root: Optional[str] = None,
    description: Optional[str] = None,
    force: bool = False,
) -> Path:
    directories = ensure_extension_structure(root)
    snake = _to_snake_case(name)
    class_name = _to_camel_case(name)
    file_path = directories["modes"] / f"{snake}_mode.py"
    if file_path.exists() and not force:
        raise ScaffoldError(f"Mode file already exists: {file_path}")

    template = textwrap.dedent(
        f'''"""Custom mode '{snake}'."""

        from datetime import datetime
        from typing import Any, Dict, Optional

        from equitrcoder.core.clean_agent import CleanAgent
        from equitrcoder.core.clean_orchestrator import CleanOrchestrator
        from equitrcoder.tools.discovery import discover_tools
        from equitrcoder.utils.git_manager import GitManager


        async def run_{snake}_mode(
            task_description: str,
            project_path: str = ".",
            agent_model: str = "moonshot/kimi-k2-0711-preview",
            orchestrator_model: Optional[str] = None,
            audit_model: Optional[str] = None,
            auto_commit: bool = True,
            max_cost: Optional[float] = None,
            max_iterations: Optional[int] = None,
            callbacks: Optional[Dict[str, Any]] = None,
        ) -> Dict[str, Any]:
            """{description or 'Custom execution mode generated by equitrcoder CLI.'}"""

            orchestrator = CleanOrchestrator(model=orchestrator_model or agent_model)
            docs_result = await orchestrator.create_docs(
                task_description=task_description,
                project_path=project_path,
            )
            if not docs_result.get("success"):
                return {
                    "success": False,
                    "error": docs_result.get("error", "Failed to plan task"),
                }

            git_manager = GitManager(repo_path=project_path)
            if auto_commit:
                git_manager.ensure_repo_is_ready()

            agent = CleanAgent(
                agent_id="{snake}_agent",
                model=agent_model,
                tools=discover_tools(),
                context=docs_result,
                max_cost=max_cost,
                max_iterations=max_iterations,
                audit_model=audit_model or agent_model,
            )

            if callbacks:
                agent.set_callbacks(**callbacks)

            agent_result = await agent.run(
                f"Complete the generated todos for: {{task_description}}"
            )

            if auto_commit and agent_result.get("success"):
                git_manager.commit(
                    f"{class_name}: auto-commit", allow_empty=True
                )

            return {
                "success": agent_result.get("success", False),
                "agent_result": agent_result,
                "docs_result": docs_result,
                "cost": agent_result.get("cost", 0.0),
                "iterations": agent_result.get("iterations", 0),
                "timestamp": datetime.utcnow().isoformat(),
            }
'''
    ).strip()

    file_path.write_text(template + "\n", encoding="utf-8")
    return file_path


def _to_snake_case(name: str) -> str:
    cleaned = "".join(ch if ch.isalnum() else "_" for ch in name)
    while "__" in cleaned:
        cleaned = cleaned.replace("__", "_")
    return cleaned.strip("_").lower() or "custom"


def _to_kebab_case(name: str) -> str:
    return _to_snake_case(name).replace("_", "-")


def _to_camel_case(name: str) -> str:
    parts = _to_snake_case(name).split("_")
    return "".join(part.capitalize() for part in parts if part) or "Custom"


def _to_title_case(name: str) -> str:
    return " ".join(word.capitalize() for word in _to_kebab_case(name).split("-"))
